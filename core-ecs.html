<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Structure &raquo; Core &raquo; ECS | CUBOS.</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon-dark.png" type="image/png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">CUBOS.</a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Pages</a></li>
            <li><a href="modules.html">Modules</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="structure.html">Structure</a> &raquo;</span>
          <span class="m-breadcrumb"><a href="core.html">Core</a> &raquo;</span>
          ECS
        </h1>
<p><a name="md_docs_pages_1_structure_1_core_6_ecs"></a> <a href="https://en.wikipedia.org/wiki/Entity_component_system">Wikipedia</a> defines <em>ECS</em> as:</p><blockquote><p>Entity Component System (ECS) is a software architectural pattern mostly used in video game development for the representation of game world objects. An ECS comprises entities composed from components of data, with systems which operate on entities&#x27; components.</p><p>ECS follows the principle of composition over inheritance, meaning that every entity is defined not by a type hierarchy, but by the components that are associated with it. Systems act globally over all entities which have the required components.</p></blockquote><p>The <em>ECS</em> thus is a vital part of the engine, since all of the rest is structured around it in some way. This sets the engine apart from other engines which follow a more traditional model, like <em>Unity</em>, <em>Unreal</em> and <em>Godot</em>.</p><section id="autotoc_md11"><h2><a href="#autotoc_md11">A primer on ECS</a></h2><section id="autotoc_md12"><h3><a href="#autotoc_md12">Why are we using this?</a></h3><p><em>ECS</em> is a powerful pattern which has been becoming more popular over the years, and even <em>Unity</em> has started integrating it into its engine. The main advantages are flexibility and performance: it avoids a lot of the problems that come with traditional object-oriented programming, and regarding performance, it excels in situations where the number of entities is high, since it makes use of cache locality. Its also easier to parallelize the systems, since they have clearly defined dependencies.</p></section><section id="autotoc_md13"><h3><a href="#autotoc_md13">Our implementation</a></h3><p><strong>CUBOS.</strong> <em>ECS</em> contains the following concepts:</p><ul><li><strong>World</strong>: the main object that holds all of the <em>ECS</em> state.</li><li><strong>Entities</strong>: represent objects in the game world (e.g. a car, a player, a tree)</li><li><strong>Components</strong>: data associated with an entity (e.g. <code>Position</code>, <code>Rotation</code>, <code>Velocity</code>, etc.).</li><li><strong>Resources</strong>: singleton-like objects which are stored per world and which do not belong to a specific entity (e.g. <code>DeltaTime</code>, <code>AssetManager</code>).</li><li><strong>Systems</strong>: functions which operate on resources and entities&#x27; components. This is where the logic is implemented.</li><li><strong>Dispatcher</strong>: decides when each system is called and knows which systems are independent from each other so they can be called at the same time (parallel computing).</li></ul><p>One important thing to note is that in an <em>ECS</em> the data is completely decoupled from the logic. What this means is that entities and components do not and should not possess any functionality other than storing data. All of the logic is relegated to the systems.</p></section><section id="autotoc_md14"><h3><a href="#autotoc_md14">How do we use it?</a></h3><p>Lets say we want to have multiple objects with positions and velocities, and every frame we want to add their velocities to their positions.</p><p>In a traditional object-oriented approach, we would something along the lines of:</p><pre class="m-code"><span class="k">class</span><span class="w"> </span><span class="nc">MyObject</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">GameObject</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">deltaTime</span><span class="p">)</span><span class="w"> </span><span class="k">override</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">position</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">velocity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">deltaTime</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">velocity</span><span class="p">;</span>
<span class="p">}</span></pre><p>In <strong>CUBOS.</strong> there are no game objects. Instead, we would define two components:</p><pre class="m-code"><span class="k">struct</span><span class="w"> </span><span class="p">[[</span><span class="n">cubos</span><span class="o">::</span><span class="n">component</span><span class="p">(</span><span class="s">&quot;position&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">VecStorage</span><span class="p">)]]</span><span class="w"> </span><span class="n">Position</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="w"> </span><span class="p">};</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="p">[[</span><span class="n">cubos</span><span class="o">::</span><span class="n">component</span><span class="p">(</span><span class="s">&quot;velocity&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">VecStorage</span><span class="p">)]]</span><span class="w"> </span><span class="n">Velocity</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="w"> </span><span class="p">};</span>
<span class="p">};</span></pre><p>To create a new entity with these components we would do something along the lines of:</p><pre class="m-code"><span class="k">auto</span><span class="w"> </span><span class="n">entity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">world</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">Position</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="n">Velocity</span><span class="w"> </span><span class="p">{});</span></pre><p>If we wanted to create a static entity with no velocity, we would just do: <code class="m-code"><span class="k">auto</span><span class="w"> </span><span class="n">entity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">world</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">Position</span><span class="w"> </span><span class="p">{});</span></code></p><p>We will also need to define our <code>DeltaTime</code> resource:</p><pre class="m-code"><span class="k">struct</span><span class="w"> </span><span class="nc">DeltaTime</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="p">};</span></pre><p>So, where does the <code>update</code> logic belong? We put it in a system (which is just a function):</p><pre class="m-code"><span class="kt">void</span><span class="w"> </span><span class="nf">velocitySystem</span><span class="p">(</span>
<span class="w">    </span><span class="n">Read</span><span class="o">&lt;</span><span class="n">DeltaTime</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dt</span><span class="p">,</span>
<span class="w">    </span><span class="n">Query</span><span class="o">&lt;</span><span class="n">Write</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Read</span><span class="o">&lt;</span><span class="n">Velocity</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">query</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">entity</span><span class="p">,</span><span class="w"> </span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="n">velocity</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">query</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">position</span><span class="o">-&gt;</span><span class="n">vec</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">velocity</span><span class="o">-&gt;</span><span class="n">vec</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dt</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span></pre><p>In this system we take two arguments: the delta time we want to read and a query over all entities with both positions and velocities. We request mutable reference to positions and constant references to velocities, since we only need to modify the positions.</p><p>We can then iterate over all queried entities and update their positions using their velocities and the delta time.</p></section></section><section id="autotoc_md15"><h2><a href="#autotoc_md15">Going further</a></h2><section id="autotoc_md16"><h3><a href="#autotoc_md16">Registering resources and components</a></h3><p>Before components and resources are used in a <em>World</em>, they must be registered on it. This should be done once, at the start of the program. For example, for the previous example we would need to do:</p><pre class="m-code"><span class="n">world</span><span class="p">.</span><span class="n">registerComponent</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">world</span><span class="p">.</span><span class="n">registerComponent</span><span class="o">&lt;</span><span class="n">Velocity</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">world</span><span class="p">.</span><span class="n">registerResource</span><span class="o">&lt;</span><span class="n">DeltaTime</span><span class="o">&gt;</span><span class="p">();</span></pre></section><section id="autotoc_md17"><h3><a href="#autotoc_md17">Commands</a></h3><p>When you have direct access to the <em>World</em>, you can manipulate entities directly:</p><pre class="m-code"><span class="k">auto</span><span class="w"> </span><span class="n">entity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">world</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">Position</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="n">Velocity</span><span class="w"> </span><span class="p">{});</span>
<span class="n">world</span><span class="p">.</span><span class="n">removeComponent</span><span class="o">&lt;</span><span class="n">Velocity</span><span class="o">&gt;</span><span class="p">(</span><span class="n">entity</span><span class="p">);</span>
<span class="n">world</span><span class="p">.</span><span class="n">addComponent</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span><span class="w"> </span><span class="n">MyComponent</span><span class="w"> </span><span class="p">{});</span>
<span class="n">world</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">entity</span><span class="p">);</span></pre><p>What if you want to create, for example, a spawner system which creates new entities? You&#x27;re probably thinking that we could just pass the world to the system. This isn&#x27;t allowed, since it would give &#x27;too much&#x27; power to the system and we wouldn&#x27;t be able to determine exactly its requirements and effects. So, how do we do it?</p><p>Until now we&#x27;ve seen systems which operate only on resources and queries. Systems may also receive a third type of argument: <code>Commands</code>. <code>Commands</code> objects store <em>ECS</em> commands to be executed at a later time, when its safe to do so. A possible spawner system could look like this:</p><pre class="m-code"><span class="kt">void</span><span class="w"> </span><span class="nf">spawnerSystem</span><span class="p">(</span>
<span class="w">    </span><span class="n">Commands</span><span class="w"> </span><span class="n">commands</span><span class="p">,</span>
<span class="w">    </span><span class="n">Query</span><span class="o">&lt;</span><span class="n">Read</span><span class="o">&lt;</span><span class="n">Spawner</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Read</span><span class="o">&lt;</span><span class="n">Position</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">spawners</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">entity</span><span class="p">,</span><span class="w"> </span><span class="n">spawner</span><span class="p">,</span><span class="w"> </span><span class="n">position</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">spawners</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">commands</span><span class="p">.</span><span class="n">create</span><span class="p">(</span>
<span class="w">            </span><span class="n">Position</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">position</span><span class="o">-&gt;</span><span class="n">vec</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="n">Velocity</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="w"> </span><span class="p">)}</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="n">commands</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">entity</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span></pre><p>This system iterates over all entities with a <code>Spawner</code> component and a <code>Position</code> and creates new entities on their positions with a velocity of <code>(0, 0, 1)</code>, and then destroys the spawner entity. This is safe to do, since commands are executed only when no system is iterating over the same entities.</p></section><section id="autotoc_md18"><h3><a href="#autotoc_md18">Blueprints</a></h3><p>A common pattern in game engines is to have a way to create entities in bundles, such as <em>Unity</em>&#x27;s <em>prefabs</em>. In <strong>CUBOS.</strong> we call these <em>blueprints</em>. A blueprint is a set of entities and their components, which can be spawned into the world as many times as needed.</p><p>For example, if we wanted to create a blueprint for a motorbike with two wheels:</p><pre class="m-code"><span class="k">auto</span><span class="w"> </span><span class="n">motorbike</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ecs</span><span class="o">::</span><span class="n">Blueprint</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">motorbike</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Position</span><span class="p">{...},</span><span class="w"> </span><span class="p">...);</span>
<span class="n">motorbike</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;front_wheel&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Parent</span><span class="p">{</span><span class="n">body</span><span class="p">},</span><span class="w"> </span><span class="p">...);</span>
<span class="n">motorbike</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;back_wheel&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Parent</span><span class="p">{</span><span class="n">body</span><span class="p">},</span><span class="w"> </span><span class="p">...);</span></pre><p>To spawn the blueprint into the world:</p><pre class="m-code"><span class="c1">// You can just spawn the bike as is.</span>
<span class="n">commands</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">motorbike</span><span class="p">);</span>

<span class="c1">// Lets say we want to spawn the bike in a different position.</span>
<span class="c1">// You can override components of the spawned entities.</span>
<span class="n">commands</span>
<span class="w">    </span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">motorbike</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Position</span><span class="p">{...});</span></pre><section id="autotoc_md19"><h4><a href="#autotoc_md19">Merging blueprints</a></h4><p>It&#x27;s possible to merge a blueprint into another one. Lets say we have a blueprint for the wheels of the motorbike:</p><pre class="m-code"><span class="k">auto</span><span class="w"> </span><span class="n">wheel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ecs</span><span class="o">::</span><span class="n">Blueprint</span><span class="p">();</span>
<span class="n">wheel</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;wheel&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span></pre><p>When creating the motorbike blueprint, we can merge the wheel blueprint into it:</p><pre class="m-code"><span class="k">auto</span><span class="w"> </span><span class="n">motorbike</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ecs</span><span class="o">::</span><span class="n">Blueprint</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">motorbike</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Position</span><span class="p">{...},</span><span class="w"> </span><span class="p">...);</span>
<span class="n">motorbike</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="s">&quot;front&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">wheel</span><span class="p">);</span>
<span class="n">motorbike</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="s">&quot;back&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">wheel</span><span class="p">);</span></pre><p>When spawning the motorbike blueprint, the entities of the wheel blueprint will be accessible with the prefix we gave them:</p><pre class="m-code"><span class="n">commands</span>
<span class="w">    </span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">motorbike</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;front.wheel&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="w">    </span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;back.wheel&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span></pre></section></section><section id="autotoc_md20"><h3><a href="#autotoc_md20">Dispatcher</a></h3><p>The <a href="classcubos_1_1core_1_1ecs_1_1Dispatcher.html" class="m-doc">Dispatcher</a> is the object which manages when each system is called. It is used to organize the order in which systems are called each frame (or at startup) and to organize the systems in a way to know which systems do not share resources between them, as in, don&#x27;t write and read from the same component or resource at the same time) so they can be called in parallel.</p><section id="autotoc_md21"><h4><a href="#autotoc_md21">How is it organized?</a></h4><p>The dispatcher keeps a list of <strong>stages</strong>, each stage represents a step in which its systems are called (possibly in parallel). Each stage has a list of <strong>systems</strong>. Since these systems may be called in parallel, they must not share resources between them.</p></section><section id="autotoc_md22"><h4><a href="#autotoc_md22">Adding systems to the dispatcher</a></h4><p>When a system is added to the dispatcher, to a stage which was not yet created, the <a href="classcubos_1_1core_1_1ecs_1_1Dispatcher.html" class="m-doc">Dispatcher</a> will create a new stage and put it in the default position.</p></section><section id="autotoc_md23"><h4><a href="#autotoc_md23">Stage ordering</a></h4><p>If you want to specify a certain order for the stages, you can use the Dispatcher::putStageBefore and Dispatcher::putStageAfter methods. These move a stage to a certain position in the list of stages, in relation to another stage.</p><p>You can also set the default position for new stages using the Dispatcher::setDefaultStage.</p></section></section></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>CUBOS.. Created with <a href="https://doxygen.org/">Doxygen</a> 1.9.1 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
