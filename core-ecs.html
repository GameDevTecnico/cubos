<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.9.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CUBOS.: ECS</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
</head>
<body>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname">CUBOS.
                                &#160;<span id="projectnumber">0.1.0</span>
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('core-ecs.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ECS </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_1_structure_1_core_6_ecs"></a> <a href="https://en.wikipedia.org/wiki/Entity_component_system">Wikipedia</a> defines <em>ECS</em> as:</p>
<blockquote class="doxtable">
<p>Entity Component System (ECS) is a software architectural pattern mostly used in video game development for the representation of game world objects. An ECS comprises entities composed from components of data, with systems which operate on entities' components.</p>
<p>ECS follows the principle of composition over inheritance, meaning that every entity is defined not by a type hierarchy, but by the components that are associated with it. Systems act globally over all entities which have the required components. </p>
</blockquote>
<p>The <em>ECS</em> thus is a vital part of the engine, since all of the rest is structured around it in some way. This sets the engine apart from other engines which follow a more traditional model, like <em>Unity</em>, <em>Unreal</em> and <em>Godot</em>.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
A primer on ECS</h1>
<h2><a class="anchor" id="autotoc_md20"></a>
Why are we using this?</h2>
<p><em>ECS</em> is a powerful pattern which has been becoming more popular over the years, and even <em>Unity</em> has started integrating it into its engine. The main advantages are flexibility and performance: it avoids a lot of the problems that come with traditional object-oriented programming, and regarding performance, it excels in situations where the number of entities is high, since it makes use of cache locality. Its also easier to parallelize the systems, since they have clearly defined dependencies.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Our implementation</h2>
<p><b>CUBOS.</b> <em>ECS</em> contains the following concepts:</p><ul>
<li><b>World</b>: the main object that holds all of the <em>ECS</em> state.</li>
<li><b>Entities</b>: represent objects in the game world (e.g. a car, a player, a tree)</li>
<li><b>Components</b>: data associated with an entity (e.g. <code>Position</code>, <code>Rotation</code>, <code>Velocity</code>, etc.).</li>
<li><b>Resources</b>: singleton-like objects which are stored per world and which do not belong to a specific entity (e.g. <code>DeltaTime</code>, <code>AssetManager</code>).</li>
<li><b>Systems</b>: functions which operate on resources and entities' components. This is where the logic is implemented.</li>
<li><b>Dispatcher</b>: decides when each system is called and knows which systems are independent from each other so they can be called at the same time (parallel computing).</li>
</ul>
<p>One important thing to note is that in an <em>ECS</em> the data is completely decoupled from the logic. What this means is that entities and components do not and should not possess any functionality other than storing data. All of the logic is relegated to the systems.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
How do we use it?</h2>
<p>Lets say we want to have multiple objects with positions and velocities, and every frame we want to add their velocities to their positions.</p>
<p>In a traditional object-oriented approach, we would something along the lines of:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyObject : <span class="keyword">public</span> GameObject</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> update(<span class="keywordtype">float</span> deltaTime)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        this-&gt;position += this-&gt;velocity * deltaTime;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    glm::vec3 position;</div>
<div class="line">    glm::vec3 velocity;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In <b>CUBOS.</b> there are no game objects. Instead, we would define two components:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>[[cubos::component(&quot;position&quot;, VecStorage)]] Position</div>
<div class="line">{</div>
<div class="line">    glm::vec3 vec = { 0.0f, 0.0f, 0.0f };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>[[cubos::component(&quot;velocity&quot;, VecStorage)]] Velocity</div>
<div class="line">{</div>
<div class="line">    glm::vec3 vec = { 0.0f, 0.0f, 0.0f };</div>
<div class="line">};</div>
</div><!-- fragment --><p>To create a new entity with these components we would do something along the lines of:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> entity = world-&gt;create(Position {}, Velocity {});</div>
</div><!-- fragment --><p>If we wanted to create a static entity with no velocity, we would just do: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> entity = world-&gt;create(Position {});</div>
</div><!-- fragment --><p>We will also need to define our <code>DeltaTime</code> resource: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>DeltaTime</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> value = 0.0f;</div>
<div class="line">};</div>
</div><!-- fragment --><p>So, where does the <code>update</code> logic belong? We put it in a system (which is just a function):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> velocitySystem(</div>
<div class="line">    <span class="keyword">const</span> DeltaTime&amp; dt,</div>
<div class="line">    core::ecs::Query&lt;Position&amp;, const Velocity&amp;&gt; query)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> [entity, position, velocity] : query)</div>
<div class="line">    {</div>
<div class="line">        position.vec += velocity.vec * dt.value;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this system we take two arguments: the delta time we want to read and a query over all entities with both positions and velocities. We request mutable reference to positions and constant references to velocities, since we only need to modify the positions.</p>
<p>We can then iterate over all queried entities and update their positions using their velocities and the delta time.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Going further</h1>
<h2><a class="anchor" id="autotoc_md24"></a>
Registering resources and components</h2>
<p>Before components and resources are used in a <em>World</em>, they must be registered on it. This should be done once, at the start of the program. For example, for the previous example we would need to do:</p>
<div class="fragment"><div class="line">world.registerComponent&lt;Position&gt;();</div>
<div class="line">world.registerComponent&lt;Velocity&gt;();</div>
<div class="line">world.registerResource&lt;DeltaTime&gt;();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25"></a>
Commands</h2>
<p>When you have direct access to the <em>World</em>, you can manipulate entities directly: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> entity = world.create(Position {}, Velocity {});</div>
<div class="line">world.removeComponent&lt;Velocity&gt;(entity);</div>
<div class="line">world.addComponent(entity, MyComponent {});</div>
<div class="line">world.destroy(entity);</div>
</div><!-- fragment --><p>What if you want to create, for example, a spawner system which creates new entities? You're probably thinking that we could just pass the world to the system. This isn't allowed, since it would give 'too much' power to the system and we wouldn't be able to determine exactly its requirements and effects. So, how do we do it?</p>
<p>Until now we've seen systems which operate only on resources and queries. Systems may also receive a third type of argument: <code>Commands</code>. <code>Commands</code> objects store <em>ECS</em> commands to be executed at a later time, when its safe to do so. A possible spawner system could look like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> spawnerSystem(</div>
<div class="line">    core::ecs::Commands&amp; commands,</div>
<div class="line">    core::ecs::Query&lt;const Spawner&amp;, const Position&amp;&gt; spawners)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> [entity, spawner, position] : spawners)</div>
<div class="line">    {</div>
<div class="line">        commands.create(</div>
<div class="line">            Position { position.vec },</div>
<div class="line">            Velocity { glm::vec3(0.0f, 0.0f, 1.0f )}</div>
<div class="line">        );</div>
<div class="line">        commands.destroy(entity);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This system iterates over all entities with a <code>Spawner</code> component and a <code>Position</code> and creates new entities on their positions with a velocity of <code>(0, 0, 1)</code>, and then destroys the spawner entity. This is safe to do, since commands are executed only when no system is iterating over the same entities.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Blueprints</h2>
<p>A common pattern in game engines is to have a way to create entities in bundles, such as <em>Unity</em>'s <em>prefabs</em>. In <b>CUBOS.</b> we call these <em>blueprints</em>. A blueprint is a set of entities and their components, which can be spawned into the world as many times as needed.</p>
<p>For example, if we wanted to create a blueprint for a motorbike with two wheels: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> motorbike = ecs::Blueprint();</div>
<div class="line"><span class="keyword">auto</span> body = motorbike.create(<span class="stringliteral">&quot;body&quot;</span>, Position{...}, ...);</div>
<div class="line">motorbike.create(<span class="stringliteral">&quot;front_wheel&quot;</span>, Parent{body}, ...);</div>
<div class="line">motorbike.create(<span class="stringliteral">&quot;back_wheel&quot;</span>, Parent{body}, ...);</div>
</div><!-- fragment --><p>To spawn the blueprint into the world: </p><div class="fragment"><div class="line"><span class="comment">// You can just spawn the bike as is.</span></div>
<div class="line">commands.spawn(motorbike);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Lets say we want to spawn the bike in a different position.</span></div>
<div class="line"><span class="comment">// You can override components of the spawned entities.</span></div>
<div class="line">commands</div>
<div class="line">    .spawn(motorbike)</div>
<div class="line">    .add(<span class="stringliteral">&quot;body&quot;</span>, Position{...});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md27"></a>
Merging blueprints</h3>
<p>It's possible to merge a blueprint into another one. Lets say we have a blueprint for the wheels of the motorbike:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> wheel = ecs::Blueprint();</div>
<div class="line">wheel.create(<span class="stringliteral">&quot;wheel&quot;</span>, ...);</div>
</div><!-- fragment --><p>When creating the motorbike blueprint, we can merge the wheel blueprint into it: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> motorbike = ecs::Blueprint();</div>
<div class="line"><span class="keyword">auto</span> body = motorbike.create(<span class="stringliteral">&quot;body&quot;</span>, Position{...}, ...);</div>
<div class="line">motorbike.merge(<span class="stringliteral">&quot;front&quot;</span>, wheel);</div>
<div class="line">motorbike.merge(<span class="stringliteral">&quot;back&quot;</span>, wheel);</div>
</div><!-- fragment --><p>When spawning the motorbike blueprint, the entities of the wheel blueprint will be accessible with the prefix we gave them: </p><div class="fragment"><div class="line">commands</div>
<div class="line">    .spawn(motorbike)</div>
<div class="line">    .add(<span class="stringliteral">&quot;front.wheel&quot;</span>, ...)</div>
<div class="line">    .add(<span class="stringliteral">&quot;back.wheel&quot;</span>, ...);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28"></a>
Dispatcher</h2>
<p>The <a class="el" href="classcubos_1_1core_1_1ecs_1_1Dispatcher.html">Dispatcher</a> is the object which manages when each system is called. It is used to organize the order in which systems are called each frame (or at startup) and to organize the systems in a way to know which systems do not share resources between them, as in, don't write and read from the same component or resource at the same time) so they can be called in parallel.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
How is it organized?</h3>
<p>The dispatcher keeps a list of <b>stages</b>, each stage represents a step in which its systems are called (possibly in parallel). Each stage has a list of <b>systems</b>. Since these systems may be called in parallel, they must not share resources between them.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
Adding systems to the dispatcher</h3>
<p>When a system is added to the dispatcher, to a stage which was not yet created, the <a class="el" href="classcubos_1_1core_1_1ecs_1_1Dispatcher.html">Dispatcher</a> will create a new stage and put it in the default position.</p>
<h3><a class="anchor" id="autotoc_md31"></a>
Stage ordering</h3>
<p>If you want to specify a certain order for the stages, you can use the Dispatcher::putStageBefore and Dispatcher::putStageAfter methods. These move a stage to a certain position in the list of stages, in relation to another stage.</p>
<p>You can also set the default position for new stages using the Dispatcher::setDefaultStage. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath">
  <!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structure.html">Structure</a></li><li class="navelem"><a class="el" href="core.html">Core</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer"
          src="doxygen.svg" width="104" height="31" alt="doxygen" /></a> 1.9.1 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function () {
    $(document).ready(function () {
      toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
      toggleButton.title = "Toggle Light/Dark Mode"
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>