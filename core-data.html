<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.8.17" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CUBOS.: Data</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
</head>
<body>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname">CUBOS.
                                &#160;<span id="projectnumber">0.1.0</span>
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('core-data.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Data </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The namespace <a class="el" href="namespacecubos_1_1core_1_1data.html">cubos::core::data</a> provides utilities for interacting with files and also provides a serialization system.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
File System</h1>
<p><b>CUBOS.</b> provides a file system abstraction layer that allows you to access files in a representation/platform independent way.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Motivation</h2>
<p>Why is this useful? Imagine you are writing a game and you want to package it into a single executable. During development, it would be inconvenient to have to merge all the files into the executable every time you make a change. So you would probably have a folder with all the files and you would load them from there.</p>
<p>But when you package the game, you would have to merge all the files into the executable. How do you do this without having to change the code?</p>
<p>The solution is to use the file system abstraction layer. When you access files, you use the <a class="el" href="classcubos_1_1core_1_1data_1_1FileSystem.html">FileSystem</a> class. During development, you would mount a <a class="el" href="classcubos_1_1core_1_1data_1_1STDArchive.html">STDArchive</a> with the folder where the files are located. When you package the game, you would mount a <a class="el" href="classcubos_1_1core_1_1data_1_1EmbeddedArchive.html">EmbeddedArchive</a>. Code wise, you would not have to change anything, provided that the paths relative to the archive are the same.</p>
<p>This means its also possible to compress the files without any code changes.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Archive</h2>
<p>Archives represent 'gateways' to the real data in the virtual file system. Currently, there are only two types of archives:</p><ul>
<li><a class="el" href="classcubos_1_1core_1_1data_1_1STDArchive.html">STDArchive</a> - represents a file or directory in the real file system.</li>
<li><a class="el" href="classcubos_1_1core_1_1data_1_1EmbeddedArchive.html">EmbeddedArchive</a> - represents a file or directory embedded in the executable.</li>
</ul>
<p>Archives can be mounted into a path in the file system using the <a class="el" href="classcubos_1_1core_1_1data_1_1FileSystem.html#a24316e70715c3ebe4e53e13f2d01f909">FileSystem::mount</a> method. This makes it so that any path that starts with the mounted path will be redirected to the archive.</p>
<p>Archives can be configured to be read-only: files cannot be created, modified or deleted. This is useful for archives used, for example, by the assets of a game.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Files</h2>
<p><a class="el" href="classcubos_1_1core_1_1data_1_1File.html">File</a> objects represent files in the virtual file system. You can get a file from its path in the virtual file system using the <a class="el" href="classcubos_1_1core_1_1data_1_1FileSystem.html#ab7279dfd43000746d763c53e72623e5e">FileSystem::find</a> method.</p>
<p>Files can be opened for reading or writing, using the <a class="el" href="classcubos_1_1core_1_1data_1_1File.html#a91c0ed17c745118fe25a5b2c1e8ffe80">File::open</a> method.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Example</h2>
<p>You can check out the <code>embedded_archive</code> sample to see how you can use this feature.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Serialization</h1>
<p><a href="https://en.wikipedia.org/wiki/Serialization">Wikipedia</a> defines serialization as:</p>
<blockquote class="doxtable">
<p>the process of translating a data structure or object state into a format can be stored (for example, in a file or memory data buffer) or transmitted (for example, over a computer network) and reconstructed later (possibly in a different computer environment). </p>
</blockquote>
<p>How does this fit into <b>CUBOS.</b>? Well, lets say we have defined the following structure: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Fruit</div>
<div class="line">{</div>
<div class="line">    std::string name;</div>
<div class="line">    <span class="keywordtype">float</span> weight;</div>
<div class="line">    uint32_t price;</div>
<div class="line">};</div>
</div><!-- fragment --><p>What if we wanted to load this data from a file? Or save it to a file? Or even print it to the console? Our serialization system is designed to make this easy. First, we need to make the type serializable and deserializable. For that, we just need to:</p><ul>
<li>include the serializer and deserializer headers.</li>
<li>define a function for writing (serializing).</li>
<li>define a function for reading (deserializing).</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cubos/core/data/serializer.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cubos/core/data/deserializer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line">... <span class="comment">// struct Fruit definition</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// We must make sure that the functions are defined in this namespace, even if</span></div>
<div class="line"><span class="comment">// Fruit is defined in another namespace.</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacecubos_1_1core_1_1data.html">cubos::core::data</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacecubos_1_1core_1_1data.html#a97f36cce7ff37b16121110f7562a7d23">serialize</a>(Serializer&amp; s, <span class="keyword">const</span> Fruit&amp; f, <span class="keyword">const</span> <span class="keywordtype">char</span>* name)</div>
<div class="line">    {</div>
<div class="line">        s.beginObject(name);</div>
<div class="line">        s.write(f.name, <span class="stringliteral">&quot;name&quot;</span>);</div>
<div class="line">        s.write(f.weight, <span class="stringliteral">&quot;weight&quot;</span>);</div>
<div class="line">        s.write(f.price, <span class="stringliteral">&quot;price&quot;</span>);</div>
<div class="line">        s.endObject();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> deserialize(Deserializer&amp; d, Fruit&amp; f)</div>
<div class="line">    {</div>
<div class="line">        d.beginObject();</div>
<div class="line">        d.read(f.name);</div>
<div class="line">        d.read(f.weight);</div>
<div class="line">        d.read(f.price);</div>
<div class="line">        d.endObject();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>serialize</code> function is responsible for writing the data to a generic <a class="el" href="classcubos_1_1core_1_1data_1_1Serializer.html">Serializer</a>, while the <code>deserialize</code> function is responsible for reading the data from a generic <a class="el" href="classcubos_1_1core_1_1data_1_1Deserializer.html">Deserializer</a>.</p>
<p>In the serialization function, we specify that we are writing an object, and then we write the fields of the object. In the deserialization function, we specify that we are reading an object, and then we read the fields of the object, which must be done in the same order as in the serialization function.</p>
<p>The main advantage of this approach is that we have just written two simple functions, and now we are able to write and read <code>Fruit</code> objects to and from a multitude of different formats. At the moment of writing this, we have two <a class="el" href="classcubos_1_1core_1_1data_1_1Serializer.html">Serializer</a> and <a class="el" href="classcubos_1_1core_1_1data_1_1Deserializer.html">Deserializer</a> implementations: <a class="el" href="classcubos_1_1core_1_1data_1_1YAMLSerializer.html">YAMLSerializer</a> and <a class="el" href="classcubos_1_1core_1_1data_1_1YAMLDeserializer.html">YAMLDeserializer</a>, and <a class="el" href="classcubos_1_1core_1_1data_1_1BinarySerializer.html">BinarySerializer</a> and <a class="el" href="classcubos_1_1core_1_1data_1_1BinarySerializer.html">BinarySerializer</a>.</p>
<p>Let's say we would like to write a list of <code>Fruit</code> objects to the console in YAML format. First we'll need to create a <a class="el" href="classcubos_1_1core_1_1data_1_1YAMLSerializer.html">YAMLSerializer</a>: </p><div class="fragment"><div class="line"><span class="comment">// The include cubos/core/data/yaml_serializer.hpp is necessary.</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacecubos_1_1core.html">cubos::core</a>;</div>
<div class="line"><span class="keyword">auto</span> serializer = <a class="code" href="classcubos_1_1core_1_1data_1_1YAMLSerializer.html">data::YAMLSerializer</a>(<a class="code" href="classcubos_1_1core_1_1memory_1_1Stream.html#aa28b8b5cd53eed1267b62da87e053a76">memory::Stream::stdOut</a>);</div>
<div class="line">...</div>
</div><!-- fragment --><p>We've just created a <a class="el" href="classcubos_1_1core_1_1data_1_1YAMLSerializer.html">YAMLSerializer</a> object, which outputs to the standard output stream. Now, let's write a list of <code>Fruit</code> objects, and some more test data: </p><div class="fragment"><div class="line">...</div>
<div class="line">std::vector&lt;Fruit&gt; fruits = {</div>
<div class="line">    Fruit { <span class="stringliteral">&quot;Apple&quot;</span>, 0.5f, 10 },</div>
<div class="line">    Fruit { <span class="stringliteral">&quot;Orange&quot;</span>, 0.3f, 20 },</div>
<div class="line">    Fruit { <span class="stringliteral">&quot;Banana&quot;</span>, 0.2f, 30 },</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">serializer.write(fruits, <span class="stringliteral">&quot;fruits&quot;</span>);</div>
<div class="line">serializer.write(42, <span class="stringliteral">&quot;number&quot;</span>);</div>
</div><!-- fragment --><p>Since <code>Fruit</code> and <code>std::vector&lt;T&gt;</code> are both serializable (for <code>Fruit</code>, we defined a <code>serialize</code> function, and <code>std::vector&lt;T&gt;</code> has one defined automatically for every <code>T</code> which is serialiable), we can just use <a class="el" href="classcubos_1_1core_1_1data_1_1Serializer.html#a5f152aac97f3df1ea0b11483a472a869">Serializer::write</a>.</p>
<p>This piece of code should output the following to the console: </p><div class="fragment"><div class="line">---</div>
<div class="line">fruits:</div>
<div class="line">- name: Apple</div>
<div class="line">  weight: 0.5</div>
<div class="line">  price: 10</div>
<div class="line">- name: Orange</div>
<div class="line">  weight: 0.3</div>
<div class="line">  price: 20</div>
<div class="line">- name: Banana</div>
<div class="line">  weight: 0.2</div>
<div class="line">  price: 30</div>
<div class="line">number: 42</div>
<div class="line">...</div>
</div><!-- fragment --><p>Until now we've only written data. What if we wanted to read the data back? Let's now create a <a class="el" href="classcubos_1_1core_1_1data_1_1YAMLDeserializer.html">YAMLDeserializer</a> object, which reads from the standard input stream: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> deserializer = data::YAMLDeserializer(memory::Stream::stdIn);</div>
<div class="line">...</div>
</div><!-- fragment --><p>For the deserialization, we can just use <a class="el" href="classcubos_1_1core_1_1data_1_1Deserializer.html#a2628f0d35c899f2da2faaf87c70dbf01">Deserializer::read</a>, because, once again, <code>Fruit</code> and <code>std::vector&lt;T&gt;</code> are both deserializable.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">std::vector&lt;Fruit&gt; fruits;</div>
<div class="line"><span class="keywordtype">int</span> number;</div>
<div class="line"> </div>
<div class="line">deserializer.read(fruits);</div>
<div class="line">deserializer.read(number);</div>
</div><!-- fragment --><p>Now, if you run this code, and feed it the output of the previous code, you should get the same list of fruits and number back.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Context serializable types</h2>
<p>Until now, we've only covered trivially serializable types: they can be serialized without providing any additional context. There are however, some types which do require additional context. Imagine we want to serialize the following structure: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Human</div>
<div class="line">{</div>
<div class="line">    std::string name;</div>
<div class="line">    Human* mother;</div>
<div class="line">    Human* father;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> Family = std::vector&lt;Human&gt;;</div>
</div><!-- fragment --><p>Lets say that any of the members of the <code>Human</code> struct can be null, but that when they're not, they always point to a valid <code>Human</code> object within the same <code>Family</code> object.</p>
<p>A valid family, would be, for example: </p><div class="fragment"><div class="line">Family family;</div>
<div class="line">family.resize(4);</div>
<div class="line">family[0] = { <span class="stringliteral">&quot;John&quot;</span>, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span> };</div>
<div class="line">family[1] = { <span class="stringliteral">&quot;Jane&quot;</span>, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span> };</div>
<div class="line">family[2] = { <span class="stringliteral">&quot;Jack&quot;</span>, &amp;family[0], &amp;family[1] };</div>
<div class="line">family[3] = { <span class="stringliteral">&quot;Jill&quot;</span>, &amp;family[0], &amp;family[1] };</div>
<div class="line"><span class="comment">// John and Jane have two children, Jack and Jill.</span></div>
</div><!-- fragment --><p>How would we define a serialization function for this type? The first thing that comes to mind is to recursively serialize the father and mother of each human, and then serialize its name. Then, if <code>Human</code> is serializable, we could just do <code>serializer.write(family, "family");</code>. <em>Wrong.</em> If we serialized it to YAML, we would get something like this: </p><div class="fragment"><div class="line">---</div>
<div class="line">family:</div>
<div class="line">- name: John</div>
<div class="line">  mother: null</div>
<div class="line">  father: null</div>
<div class="line">- name: Jane</div>
<div class="line">  mother: null</div>
<div class="line">  father: null</div>
<div class="line">- name: Jack</div>
<div class="line">  mother:</div>
<div class="line">    name: John</div>
<div class="line">    mother: null</div>
<div class="line">    father: null</div>
<div class="line">  father:</div>
<div class="line">    name: Jane</div>
<div class="line">    mother: null</div>
<div class="line">    father: null</div>
<div class="line">- name: Jill</div>
<div class="line">  mother: ...</div>
<div class="line">...</div>
</div><!-- fragment --><p>As you've probably noticed, there's a lot of redundant information in this example. This is because we serialized the <code>mother</code> and <code>father</code> members of John, even though they had already been serialized.</p>
<p>If we instead, provide extra information to the serializer, we can serialize this in a more compact way - lets associate an index to each address. There is a built-in utility for situations like this: the <a class="el" href="classcubos_1_1core_1_1data_1_1SerializationMap.html">SerializationMap</a>. This utility will be our extra context.</p>
<p>This utility maps 'references' to 'identifiers', where the references represent the original object references (in our case, the pointers), and the identifiers represent the identifiers which are actually serialized. For this example, we could generate those mappings like this:</p>
<div class="fragment"><div class="line"><span class="comment">// Lets map Human* to identifiers.</span></div>
<div class="line"><span class="keyword">auto</span> map = SerializationMap&lt;Human*, int32_t&gt;();</div>
<div class="line">map.add(<span class="keyword">nullptr</span>, -1); <span class="comment">// Lets map nullptr to -1.</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; family.size(); ++i)</div>
<div class="line">    map.add(&amp;family[i], i); <span class="comment">// Add a mapping index &lt;-&gt; Human*</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Then we serialize the family, using the map.</span></div>
<div class="line">serializer.write(family, map, <span class="stringliteral">&quot;family&quot;</span>);</div>
</div><!-- fragment --><p>The serialization functions for <code>Human</code> then could be written as:</p>
<div class="fragment"><div class="line"><span class="comment">// Once again, we must put these in the right namespace.</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacecubos_1_1core_1_1data.html">cubos::core::data</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespacecubos_1_1core_1_1data.html#a97f36cce7ff37b16121110f7562a7d23">serialize</a>(Serializer&amp; s, <span class="keyword">const</span> Human&amp; h, <span class="keyword">const</span> SerializationMap&lt;Human*, uint32_t&gt;&amp; map, <span class="keyword">const</span> <span class="keywordtype">char</span>* name)</div>
<div class="line">    {</div>
<div class="line">        s.beginObject(name);</div>
<div class="line">        s.write(h.name, <span class="stringliteral">&quot;name&quot;</span>);</div>
<div class="line">        s.write(map-&gt;getId(h.mother), <span class="stringliteral">&quot;mother&quot;</span>);</div>
<div class="line">        s.write(map-&gt;getId(h.father), <span class="stringliteral">&quot;father&quot;</span>);</div>
<div class="line">        s.endObject();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> deserialize(Deserializer&amp; d, Human&amp; h, <span class="keyword">const</span> SerializationMap&lt;Human*, uint32_t&gt;&amp; map)</div>
<div class="line">    {</div>
<div class="line">        int32_t id;</div>
<div class="line"> </div>
<div class="line">        d.beginObject();</div>
<div class="line">        d.read(h.name);</div>
<div class="line">        d.read(<span class="keywordtype">id</span>);</div>
<div class="line">        h.mother = map-&gt;getRef(<span class="keywordtype">id</span>); <span class="comment">// Here we do the opposite, from id to Human*        </span></div>
<div class="line">        d.read(<span class="keywordtype">id</span>);</div>
<div class="line">        h.father = map-&gt;getRef(<span class="keywordtype">id</span>);</div>
<div class="line">        d.endObject();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>With this, serializing the family to YAML should output the following: </p><div class="fragment"><div class="line">---</div>
<div class="line">family:</div>
<div class="line">- name: John</div>
<div class="line">  mother: -1</div>
<div class="line">  father: -1</div>
<div class="line">- name: Jane</div>
<div class="line">  mother: -1</div>
<div class="line">  father: -1</div>
<div class="line">- name: Jack</div>
<div class="line">  mother: 0</div>
<div class="line">  father: 1</div>
<div class="line">- name: Jill</div>
<div class="line">  mother: 0</div>
<div class="line">  father: 1</div>
<div class="line">...</div>
</div><!-- fragment --><p>Which contains exactly the information we need to reconstruct the family! You can check the <a class="el" href="core.html">Core</a> <code>serialization.cpp</code> sample for more details.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Going further</h2>
<p>One way we're taking advantage of the serialization system is to use it to both show object's properties in the UI (with <code>ImGui</code>) and also allow the user to edit those properties.</p>
<p>For this purpose, we needed an easy way to inspect properties of any serializable object, and we also needed a way to edit those properties. So, we came up with the <a class="el" href="classcubos_1_1core_1_1data_1_1Package.html">Package</a> class. Any object which provides a trivial serialization function (that is, a function which won't receive extra arguments) can be packaged. We can also unpackage packages into trivially deserializable objects!</p>
<p>Previously we defined a trivially serializable <code>Fruit</code> struct. Let's say we wanted to inspect which properties a <code>Fruit</code> object has, dynamically. We can first package it:</p>
<div class="fragment"><div class="line">Fruit fruit = { <span class="stringliteral">&quot;Apple&quot;</span>, 0.5f, 10 };</div>
<div class="line"><span class="keyword">auto</span> pkg = Package::from(fruit);</div>
<div class="line">...</div>
</div><!-- fragment --><p>We can then inspect its fields:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">std::cout &lt;&lt; pkg.size() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">// 3 fields</span></div>
<div class="line">std::cout &lt;&lt; pkg.field(<span class="stringliteral">&quot;name&quot;</span>).get&lt;std::string&gt;() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">// Apple</span></div>
<div class="line">std::cout &lt;&lt; pkg.field(<span class="stringliteral">&quot;weight&quot;</span>).get&lt;<span class="keywordtype">float</span>&gt;() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">// 0.5f</span></div>
<div class="line">std::cout &lt;&lt; pkg.field(<span class="stringliteral">&quot;price&quot;</span>).get&lt;int32_t&gt;() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">// 10</span></div>
</div><!-- fragment --><p>And even edit them if necessary:</p>
<div class="fragment"><div class="line">pkg.field(<span class="stringliteral">&quot;name&quot;</span>).set(<span class="stringliteral">&quot;Banana&quot;</span>);</div>
<div class="line">...</div>
</div><!-- fragment --><p>If we edit the package, the original object won't be immediately updated. To do this, we need to use the <a class="el" href="classcubos_1_1core_1_1data_1_1Package.html#a2c1044dbf4dce5f7e2f2a5c0a6358d87">into</a> method. This method only works with trivially deserializable objects, and will return true or false, depending on whether the conversion was successful.</p>
<div class="fragment"><div class="line">Fruit fruit = { <span class="stringliteral">&quot;Apple&quot;</span>, 0.5f, 10 };</div>
<div class="line"><span class="keyword">auto</span> pkg = Package::from(fruit);</div>
<div class="line">pkg.field(<span class="stringliteral">&quot;name&quot;</span>).set(<span class="stringliteral">&quot;Banana&quot;</span>);</div>
<div class="line">pkg.into(fruit); <span class="comment">// Writes the package contents into the fruit object.</span></div>
<div class="line">std::cout &lt;&lt; fruit.name &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">// Banana</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacecubos_1_1core_1_1data_html_a97f36cce7ff37b16121110f7562a7d23"><div class="ttname"><a href="namespacecubos_1_1core_1_1data.html#a97f36cce7ff37b16121110f7562a7d23">cubos::core::data::serialize</a></div><div class="ttdeci">void serialize(Serializer &amp;serializer, const Package &amp;pkg, const char *name)</div></div>
<div class="ttc" id="aclasscubos_1_1core_1_1memory_1_1Stream_html_aa28b8b5cd53eed1267b62da87e053a76"><div class="ttname"><a href="classcubos_1_1core_1_1memory_1_1Stream.html#aa28b8b5cd53eed1267b62da87e053a76">cubos::core::memory::Stream::stdOut</a></div><div class="ttdeci">static Stream &amp; stdOut</div><div class="ttdoc">Stream wrapper for stdout.</div><div class="ttdef"><b>Definition:</b> stream.hpp:28</div></div>
<div class="ttc" id="aclasscubos_1_1core_1_1data_1_1YAMLSerializer_html"><div class="ttname"><a href="classcubos_1_1core_1_1data_1_1YAMLSerializer.html">cubos::core::data::YAMLSerializer</a></div><div class="ttdoc">Implementation of the abstract Serializer class for serializing to YAML.</div><div class="ttdef"><b>Definition:</b> yaml_serializer.hpp:12</div></div>
<div class="ttc" id="anamespacecubos_1_1core_html"><div class="ttname"><a href="namespacecubos_1_1core.html">cubos::core</a></div><div class="ttdoc">Namespace of the CUBOS. core library.</div><div class="ttdef"><b>Definition:</b> archive.hpp:6</div></div>
<div class="ttc" id="anamespacecubos_1_1core_1_1data_html"><div class="ttname"><a href="namespacecubos_1_1core_1_1data.html">cubos::core::data</a></div><div class="ttdoc">Contains the virtual file and serialization systems, and other data related utilities.</div><div class="ttdef"><b>Definition:</b> archive.hpp:6</div></div>
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath">
  <!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structure.html">Structure</a></li><li class="navelem"><a class="el" href="core.html">Core</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer"
          src="doxygen.svg" width="104" height="31" alt="doxygen" /></a> 1.8.17 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function () {
    $(document).ready(function () {
      toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
      toggleButton.title = "Toggle Light/Dark Mode"
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>